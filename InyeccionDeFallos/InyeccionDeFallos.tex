\chapter{Inyección de fallos}
\label{ch:InyeccionDeFallos}

\lettrine[lraise=-0.1, lines=2, loversize=0.2]{L}{a} inyección de fallos es una
técnica que permite recrear los efectos que produce la radiación sobre un
circuito. Esta técnica es ampliamente usada ya que permite estudiar en qué parte
de un circuito causa más efecto un error lógico y qué partes son más resistentes a
este tipo de error. El diseño de circuitos destinados a trabajar en entornos 
hostiles, donde recibirán altas dosis de radiación ionizante, encuentra en esta
técnica una gran ayuda, ya que permite estudiar la sensibilidad de sus módulos a
este tipo de errores sin necesidad de fabricarlo y testearlo bajo radiación real.
Con esto se acelera enormemente el proceso de diseño y refuerzo de circuitos
resistentes a radiación.

En nuestro caso, hemos empleado técnicas de inyección de fallos como ayuda para el
diagnóstico de \gls{SEU}, es decir, tratar de localizar el error, determinar en 
qué biestable (\textit{\gls{FF}}) se ha producido la conmutación lógica y durante
qué ciclo de reloj ha ocurrido. El papel de la técnica en el diagnóstico es el de
recrear los efectos que tendrían \gls{SEU} concretos sobre el circuito, de forma
que podamos generar una base de datos donde tener relacionados cada localización
espacial y temporal de un error lógico con su consecuencia a la salida del
circuito. Esta base de datos, en diagnóstico de \gls{SEU}, toma el nombre de
diccionario de fallos, y se obtienen mediante campañas de inyección de fallos.

Durante una campaña de inyección de fallos se ejecuta el \gls{CUT} con las mismas
señales de entrada una y otra vez, partiendo siempre desde el reset. En cada
ejecución, se inyecta un fallo en alguno de las posibles localizaciones (\gls{FF}, 
ciclo). Si el \gls{CUT} está formado por \textit{"n"} \gls{FF} y las pruebas se 
ejecutan durante \textit{"m"} ciclos de reloj, existirán \textit{"n·m"} posibles 
combinaciones donde inyectar un error lógico.

% Imagen 1 -> Ejecución de una camapaña de inyección de fallos.

Las salidas que se obtienen, ciclo a ciclo, durante una ejecución de la campaña, 
se registran y almacenan junto con la información de la inyección que las ha 
causado. Dado que solo nos interesan los errores, no que se traten de ceros cuando
deberían ser unos o viceversa, la salida del circuito (entendiendo salida como el
conjunto de las salidas de los ciclos que dura la prueba) es comparada bit a bit
con la salida que se obtendría si no existiese fallo alguno. Para llevar a cabo
esta comparación se emplea la operación lógica \textit{XOR}, ya que por
definición, toma el valor 1 únicamente cuándo sus entradas son distintas.

% Imagen 2 -> Postprocesado de la salida de un ejecución de la campaña.

% Definir run -> como XOR de golden run y las salidas -> discrepancias
Aplicandola para cada correspondiente pareja de bits entre una salida de la 
campaña y la salida del circuito sin inyecctar, conseguimos resaltar los errores
que causa el \gls{SEU} inyectado. A esta versión de la salida de una ejecución de
la campaña donde solo toman valor lógico alto los errores causados por la
inyección nos referiremos de ahora en adelante como \textit{"Run"}. Así mismo, a 
la salida del circuito durante una ejecución libre de inyecciones la denominaremos
\textit{"Golden Run"}.
% Definir golden run (arriba)

% Definir entrada del diccionario
% Decir que cada run, junto con la información de la inyección que lo ha causado,
% constituye una entrada del diccionario. Es decir, cada entrada del diccionario
% está formado por la localización de la inyección recreada (FF, ciclo) y las
% discrepancias que ha causado a la salida.


% Set de bits seleccionados -> exhaustivo


% Definir golden run

% Imagen 2

\section{FT-Unshades2}
\label{sec:FT-Unshades2}
% GOLDEN run

\endinput
