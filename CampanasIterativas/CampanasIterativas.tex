\chapter{Campañas iterativas a partir de los candidatos seleccionados}
\label{ch:CampanasIterativas}

% Explicar en qué consiste una campaña iterativa. Comentar que puede ser una buena
% solucion para cuando el diccionrio es extremadamente pequeño. -> Random sampling
% y a partir de ahi acotar
\lettrine[lraise=-0.1, lines=2, loversize=0.2]{L}{as} campañas iterativas serían
el recurso propuesto para diagnósticos que no encuentran candidatos a distancias
cero, es decir, cuando el diccionario no contiene al \gls{SEU} que queremos
diagnósticar. Esta tećnica aplica para diccionarios incompletos, ya que un
diccionario completo siempre contendrá por definición al target run.

Esta técnica se emplea en situaciones en las que el diccionario es extremadamente 
pequeño pero sin llegar a perder completamente la capacidad de diagnóstico. El
concepto es sencillo. Se obtiene un diccionario incompleto del circuito mediante
inyecciones aleatorias (\textit{"Random Sampling"}), a partir de él, realizamos el
primer diagnóstico. Obtenemos una lista preliminar de candidatos a partir de la
cual extraemos la información necesaria para una siguiente inyección, que ya no 
será aleatoria, al menos en su mayoría. El proceso de obtención de diccionario,
diagnóstico, y obtención de un nuevo diccionario a partir del el cual volver a
diagnosticar puede repetirse tantas veces como sea necesario, finalizando con la
detección de al menos una inyección que colisione con el target run.

% Reducir enormemente el espacio de inyeccion restringiendo a un rango de ciclos,
% registros, todos los regs pero en un único ciclo, un solo FF pero un rango de
% ciclos, etc
Según la información de salida del algoritmo que selecciona los candidatos,
podemos realizar nuevas campañas desde distintos enfoques.
% LISTA POSIBLES TIPOS DE CAMPAÑA
    % Campaña enfocada en ciclos
    % Campaña enfocada en registros
    % Campaña enfocada en FF concretos
    % Combinación de las anteriores.
\begin{itemize}
    \item Campaña enfocada en ciclos: si la información de salida no deja duda
        sobre en qué ciclo se localiza el \gls{SEU}, podemos realizar una campaña
        de inyección de fallos en la que sólo inyectemos durante ese ciclo en
        concreto. El espacio total a inyectar se reduce al número de biestables, y
        la longitud de la simulación se divide por la cantidad de ciclos que
        componían cada ejecución.
    \item Campaña enfocada en registros: cuando la información de la salida apunta
        claramente a un registro o un conjunto de ellos, la campaña de inyección
        de fallos a realizar podría centrarse en inyectar esas zonas del circuito,
        reduciendo el espacio de inyección al descartar de la campaña el resto de
        registros del \gls{CUT}.
    \item Campaña enfocada en biestables: del mismo modo, podríamos inyectar
        \gls{FF} concretos del \gls{CUT} en todos los ciclos posibles.
    \item Combinación de las restricciones anteriores: si el circuito es tan
        grande que toda reducción del espacio de inyección es poca, podemos acotar
        la siguiente campaña combinando restricciones. Inyectar un registro
        durante un rango de ciclos, un ciclo pero un conjunto de \gls{FF}, etc.
\end{itemize}

% Comentar con qué formato sale la información para la siguiente campaña, siendo
% el usuario el que decide qué tipo de campaña realizar.
El código que selecciona y procesa los candidatos devuelve una lista de biestables
concretos, donde cada biestable va acompañado del número de veces que ha sido
seleccionado y de un rango de ciclos que se calcula en función de la distancia en
ciclos. También se indica el ciclo central del rango, siendo posible, cuando no
cabe ninguna duda, de que el rango sea un único ciclo. Por separado, se muestran,
de existir, las inyecciones del diccionario que producen exactamente el mismo
patrón de fallos.

Con esta información, es el usuario el que decide cuál de las 4 campañas descritas
aplicar, siendo una buena opción inyectar tal cual esos biestables en el rango de
ciclos que los acompañan. En cualquier caso, si la duración de la campaña lo
permite, realizar una campaña menos acotada evitará malos diagnósticos y mínimos
locales.

% MINIMOS LOCALES
% Explicar la posibilidad de llegar a un minimo local -> soluciones planteadas
    % El uso de los 4 algoritmos simultaneamente -> 4*n candidatos
    % Posibilidad de incluir además un set de inyecciones aleatorias en la
        % siguiente campaña
Alcanzar un mínimo local en este contexto sería como "seguir una pista falsa".
Corremos el peligro de caer en un mínimo local cuando el candidato que presenta la
menos de las distancias no apunta a donde debería. Esto es más probable conforme
reducimos la exhaustividad del diccionario. De esta forma, campaña tras campaña,
acotaríamos el espacio de inyección en torno a una zona que presenta aparentemente
menos distancia al taget run, pero en la que nunca detectaremos una colisión. 

Este problema se podría evitar aumentado el número de candidatos que seleccionamos
(\textit{"n"}) o tratando de acotar más progresivamente. Otra posibilidad es la
incluir inyecciones aleatoriamente en cada nueva campaña, de forma que se aumenten
las probabilidades de estimular la zona correcta si previamente esta no estaba
contenida en el diccionario.

Las características y puntos fuertes de cada técnica en particular también pueden
propiciar la caída en un mínimo local. Esta es otra razón por la que hemos
decidido mantener los cuatro algoritmos a la hora de extraer candidatos. El
objetivo es que, si uno de los algoritmos se ve especialemente influenciado por un
mínimo local, los otros tres incluyan candidatos en la campaña que pertenezcan a
otra zona del circuito. Como mencionamos en los resultados del capítulo anterior,
la distancia en ciclo cumple especialemente bien este objetivo al no tener
capacidad para diagnosticar espacialmente por si sola.

\section{Obtención de la lista de candidatos}
\label{sec:Candidatos}
% Mencionar lo ya explicado anteriormente sobre el uso de los 4 algoritmos
% simultaneamente
% Seleccion de n candidatos de cada algoritmo
Primeramente leemos la información tanto de \textit{"dammages.csv"} como de 
\textit{"injections.csv"} y leemos el patrón de fallos a diagnósticar. En este
momento calculamos todas las distancias y agrupamos la información de las
distancias y las inyecciones en una lista. Tal y como hemos explicado para cada
distancia, realizamos la selección de los \textit{"n"} primeros candidatos con
cada una (máximo de $2 \times n$ como hemos comentado).

% Agrupacion de los candidatos en una sola lista (en el siguiente apartado
% explicamos cómo se procesa esta información)
Agrupamos los $4 \times n$ candidatos en una sola lista, manteniendo aún todas las
distancias para cada uno de ellos. A parir de este momento comenzamos a preparar
la información necesaria para la siguiente iteración.


\section{Extracción de la información para la siguiente campaña de inyección de
fallos}
\label{sec:InfoCampana}
% En este punto comprobamos si hay colision, es decir, si el diagnóstico ha
% terminado
Antes que nada, comprobamos si el diagnóstico
ha concluido, es decir, si alguno de los candidatos presenta distancia de
Levenshtein, ciclo y Hu igual a cero. Tanto en caso negativo como en positivo, 
procedemos a calcular la información de inyección recomendada para la siguiente 
campaña de inyección de fallos.

Aunque tras detectar candidatos a distancia cero pueda parecer que el diagnóstico
no puede mejorar, tenemos que tener en cuenta la posibilidad de encontrarnos ante
una colisión, por lo que la localización correcta del \gls{SEU} no sería esa.
Realizar una iteración extra y obtener una nueva lista de candidatos puede mejorar
el diagnóstico en este sentido, ya que podría llegar a localizar más inyecciones
que generen exactamente el mismo patrón, consiguiendo un diagnóstico más completo.

% Se agrupan los candidatos reg/FF repetidos y se calcula el rango de ciclos
La información recomendada para la siguiente inyección es de la forma que hemos
explicado hace un momento, biestables acompañados del número de veces que han sido
seleccionados y el rango de ciclos en el que podría estar, centrado en un ciclo
concreto e incluyendo márgenes de error. Para extraer esta información, primero
separamos las inyecciones de los candidatos en ciclo, registro y \gls{FF}. En este
punto disponemos de dos posibilidades, agrupar inyecciones por \gls{FF} o por
registros repetidos, realizando el recuento de cuántas veces se repiten. En 
nuestro caso, dado el alto porcentage de acierto inicial, hemos decidido agrupar 
los candidatos repetidos por biestables.

Por último, recorremos de nuevo la lista de candidatos que contiene las
distancias calculando el rango de ciclos en los que el algoritmo selecciona cada
uno de ellos y estimando la posición central. Esta se calcula mediante la ecuación
\ref{eq:CicloCentral}, y el margen de error que compone el rango se ha establecido
como dos veces la distancia en ciclos para cada sentido a partir del ciclo central.

\begin{equation}
    \label{eq:CicloCentral}
    Ciclo\_Central = Ciclo\_de\_inyección - Distancia\_en\_ciclos
\end{equation}

% Como resultado se obtiene una lista con toda la informacion necesaria para
% realizar la siguiente campaña recomendada
Como resultado de este proceso obtenemos una lista con toda la información
necesaria para realizar la siguiente campaña de inyección de fallos. Esta
información se muestra con el siguiente formato:
\begin{center}
    [ciclo inferior, ciclo central, ciclo superior] \hfill :/ \hfill registro/
    \hfill \gls{FF} \hfill nº de repeticiones
\end{center}

Aunque esta
información tal cual se correspondería con la próxima campaña recomendada, aún
podemos decidir manualmente, tras observar los rangos de ciclos y la variedad de
registros o \gls{FF}, si realizaremos una campaña especialmente enfocada en alguna
parte del circuito tal y como hemos comentado anteriormente.


\section{Resultados experimentales}
\label{sec:IterResults}
% Validacion de los resultados sin necesidad de inyectar (porque conocemos de
% antemano la inyeccion correcta del target run)
Los experimentos realizados para validar esta técnica se basan en la siguiente
hipótesis:

% Hipotesis realizadas para validar de esta forma
\begin{hypothesis}\label{hyp:ResIter}
    "Si el espacio de inyección propuesto por el algoritmo es lo suficientemente
    pequeño como para realizar en él una campaña exhaustiva, y en en él se
    encuentra la inyección correcta; la siguiente campaña detectará al menos una
    colisión".
\end{hypothesis}

% Comentar la hipótesis. Conocemos la inyeccion real de target run.
Conociendo de antemano la inyección del \gls{SEU} que se quiere diagnosticar, se 
puede saber si el proceso iterativo terminará detectando colisiones o no.
Podemos pues ahorrarnos el proceso de inyección de cara a validar la técnica, ya
que los experimentos de diagnóstico se están realizando para conmutaciones lógicas
simuladas, y por tanto conocemos la información de la inyección. Esta información
nos permite tanto validar la técnica como saber de antemano cuál es la mejor
campaña que podemos aplicar dada la salida del algoritmo.

% Cuando diremos que las campañas iterativas serán exitosas.
Hemos fijado \textit{"n"} a 5. Esto hace un total de 20 candidatos (con un máximo
de 40) en caso de que no se repita ninguno. Si además tenemos en cuenta que el
algoritmo nos acota también el espacio de inyección temporalmente, podemos afirmar
que este es lo suficientemente pequeño como para aplicar una campaña de inyección
de fallos exhaustiva.

Por supuesto, aún tenemos libertad para decidir a qué ciclos aplicamos la campaña,
pudiendo ampliarlos o reducirlos, y si la aplicamos a biestables concretos o si 
por el conrtrario inyecctamos en todos los \gls{FF} de los registros
seleccionados. Hemos programado un código que analiza la salida del algoritmo, la
compara con la información de la inyección y predice el resultado que se obtendría
al realizar realmente las campañas de inyección de fallos. Las posibles salidas de
este código son:
\begin{itemize}
    \item \textit{"Next campaign will fail"}: en caso de que entre los candidatos 
        no se encuentre ni el \gls{FF}, ni el registro, ni el ciclo correcto.
    \item \textit{"Will need more than one iteration to hit the target"}: cuando
        entre los candidatos se encuentra el \gls{FF} correcto, pero el ciclo está
        fuera del rango. Los nuevos candidatos extraidos del diccionario resultado
        de la siguiente inyección afinarán la predicción temporal. Una campaña
        exhaustiva para los \gls{FF} seleccionados no acotada temporalmente solo
        necesitaría una campaña extra para colisionar.
    \item "If next campaign is oriented to registers, will hit the target": tanto
        el registro como el ciclo correcto están en el espacio de inyección
        acotado, pero el biestable concreto no aparece. Si la campaña la enfocamos
        a registros, sin concretar en cuáles de sus biestables se inyecta,
        localizará al target run.
    \item "Next campaign will hit the target": tanto ciclo, como registro, como
        biestable están en el espacio de inyección seleccionado. Las campañas
        iterativas finalizarían en la siguiente iteración.
    \item "Next campaign will contain only right cycle": sólo una campaña acotada
        temporalmente aseguraría mejorar el diagnóstico en la siguiente iteración.
    \item "Will need a register oriented campaign and more than one iteration": ni
        ciclo ni biestable correcto se encuentran en el espacio de inyección
        seleccionado. A base de iterar podría mejorar el diagnóstico temporal
        empleando la información de las nuevas distancias en ciclo, pero sería
        necesario no enfocar las campañas a biestables concretos.
\end{itemize}

Evidentemente, en una aplicación real no dispondríamos de la información correcta
de la inyección, por lo que no se sabría qué tipo de campaña realizar en la
proxima iteración para mejorar el diagnóstico. La información del número de veces
que se repite cada biestable entre los candidatos puede orientarnos a la hora de
saber si realmente el \gls{FF} correcto se encuentra entre ellos o no. Aún
así, es posible que se necesiten varios intentos de selección de tipo de campaña
en caso de que, debido al gran tamaño inicial del espacio de inyección, sea
necesario acotar lo máximo posible.

% Resultados (ver correo, que ahí hago el resumen)
En líneas generales, los resultados muestran como el candidato que se repide un
mayor número de veces es el que apunta al biestable correcto si la diferencia
de repeticiones respecto al resto es notable. A pasar de lo claro
que sea este resultado, se debe inyectar también en el resto de candidatos, en caso
de que no se haya detectado colisión, para evitar caer en un mínimo local.

He seleccionado los resultados más significativos de todos los experimentos
realizados, mostrando algún ejemplo para cada posible caso de los anteiormente
enumerados.



% Hablar de cuándo se va perdiendo la capacidad de diagnóstico conforme se va
% reduciendo la exhaustividad del diciconario

% Decir que no es lo mismo un diccionario del 1% para el counter que uno del 0'87%
% para la uart porque el núemro de entradas del primer caso es ridículo


\endinput
